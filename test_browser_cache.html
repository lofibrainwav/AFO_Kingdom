<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AFO ì™•êµ­ ë¸Œë¼ìš°ì € ìºì‹œ í…ŒìŠ¤íŠ¸</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .container {
            background: rgba(255, 255, 255, 0.1);
            padding: 30px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        .test-section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
        }
        .result {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: monospace;
        }
        .success { border-left: 4px solid #4CAF50; }
        .error { border-left: 4px solid #f44336; }
        .warning { border-left: 4px solid #ff9800; }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
        }
        button:hover { background: #45a049; }
        .performance { background: #2196F3; }
        .performance:hover { background: #1976D2; }
        .cache { background: #FF9800; }
        .cache:hover { background: #F57C00; }
    </style>
</head>
<body>
    <div class="container">
        <h1>âš”ï¸ AFO ì™•êµ­ ë¸Œë¼ìš°ì € ìºì‹œ í…ŒìŠ¤íŠ¸</h1>
        <p>ì¸í„°ë„· ë¦¬ì„œì¹˜ ê¸°ë°˜ìœ¼ë¡œ í•´ê²°ëœ ëª¨ë“  ë¬¸ì œë¥¼ ë¸Œë¼ìš°ì €ì—ì„œ ê²€ì¦í•©ë‹ˆë‹¤.</p>

        <div class="test-section">
            <h2>ğŸ¯ API ì—°ê²° í…ŒìŠ¤íŠ¸</h2>
            <button onclick="testAPIConnection()">API ì—°ê²° í™•ì¸</button>
            <div id="api-result" class="result"></div>
        </div>

        <div class="test-section">
            <h2>ğŸ—„ï¸ ìºì‹œ í—¤ë” í…ŒìŠ¤íŠ¸</h2>
            <button class="cache" onclick="testCacheHeaders()">ìºì‹œ í—¤ë” ê²€ì¦</button>
            <div id="cache-result" class="result"></div>
        </div>

        <div class="test-section">
            <h2>âš¡ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸</h2>
            <button class="performance" onclick="testPerformance()">ì„±ëŠ¥ ì¸¡ì •</button>
            <div id="perf-result" class="result"></div>
        </div>

        <div class="test-section">
            <h2>ğŸ”„ ìºì‹œ íš¨ê³¼ í…ŒìŠ¤íŠ¸</h2>
            <button onclick="testCacheEffect()">ìºì‹œ íš¨ê³¼ í™•ì¸</button>
            <div id="cache-effect-result" class="result"></div>
        </div>

        <div class="test-section">
            <h2>ğŸ“Š ì¢…í•© ê²€ì¦ ê²°ê³¼</h2>
            <button onclick="runAllTests()">ëª¨ë“  í…ŒìŠ¤íŠ¸ ì‹¤í–‰</button>
            <div id="comprehensive-result" class="result"></div>
        </div>
    </div>

    <script>
        const API_BASE = 'http://127.0.0.1:8010';
        let testResults = {};

        async function makeRequest(endpoint, options = {}) {
            const startTime = performance.now();
            try {
                const response = await fetch(`${API_BASE}${endpoint}`, {
                    method: 'GET',
                    headers: {
                        'Cache-Control': 'no-cache',
                        ...options.headers
                    },
                    ...options
                });
                const endTime = performance.now();
                const responseTime = endTime - startTime;

                return {
                    success: response.ok,
                    status: response.status,
                    statusText: response.statusText,
                    headers: Object.fromEntries(response.headers.entries()),
                    responseTime: responseTime.toFixed(2),
                    data: response.ok ? await response.json() : null
                };
            } catch (error) {
                const endTime = performance.now();
                return {
                    success: false,
                    error: error.message,
                    responseTime: (endTime - startTime).toFixed(2)
                };
            }
        }

        function displayResult(elementId, result, type = 'info') {
            const element = document.getElementById(elementId);
            element.className = `result ${type}`;
            element.innerHTML = `<pre>${JSON.stringify(result, null, 2)}</pre>`;
        }

        async function testAPIConnection() {
            const result = await makeRequest('/api/health/comprehensive');
            testResults.apiConnection = result;

            if (result.success) {
                displayResult('api-result', {
                    status: 'âœ… ì—°ê²° ì„±ê³µ',
                    response_time: `${result.responseTime}ms`,
                    trinity_score: result.data?.trinity_score || 'N/A',
                    api_status: result.data?.status || 'N/A'
                }, 'success');
            } else {
                displayResult('api-result', {
                    status: 'âŒ ì—°ê²° ì‹¤íŒ¨',
                    error: result.error,
                    response_time: `${result.responseTime}ms`
                }, 'error');
            }
        }

        async function testCacheHeaders() {
            const result = await makeRequest('/api/health/comprehensive');
            testResults.cacheHeaders = result;

            const cacheHeaders = {
                'Cache-Control': result.headers['cache-control'] || result.headers['Cache-Control'],
                'X-Cache-Source': result.headers['x-cache-source'] || result.headers['X-Cache-Source'],
                'X-Cache': result.headers['x-cache'] || result.headers['X-Cache']
            };

            const hasAllHeaders = cacheHeaders['Cache-Control'] && cacheHeaders['X-Cache-Source'] && cacheHeaders['X-Cache'];
            const successRate = Object.values(cacheHeaders).filter(v => v).length;

            displayResult('cache-result', {
                status: hasAllHeaders ? 'ğŸ‰ ì™„ë²½ ì„±ê³µ' : 'âš ï¸ ë¶€ë¶„ ì„±ê³µ',
                success_rate: `${successRate}/3`,
                headers: cacheHeaders,
                verification: hasAllHeaders ? 'ë¸Œë¼ìš°ì € ìºì‹œ í—¤ë” ì •ìƒ ì ìš©' : 'ì¼ë¶€ í—¤ë” ëˆ„ë½'
            }, hasAllHeaders ? 'success' : 'warning');
        }

        async function testPerformance() {
            const results = [];
            for (let i = 0; i < 5; i++) {
                const result = await makeRequest('/api/health/comprehensive');
                results.push({
                    attempt: i + 1,
                    response_time: result.responseTime,
                    cache_hit: result.headers['x-cache'] === 'HIT'
                });
            }

            const avgTime = results.reduce((sum, r) => sum + parseFloat(r.response_time), 0) / results.length;
            const cacheHits = results.filter(r => r.cache_hit).length;

            testResults.performance = { results, avgTime, cacheHits };

            displayResult('perf-result', {
                status: 'âœ… ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ ì™„ë£Œ',
                average_response_time: `${avgTime.toFixed(2)}ms`,
                cache_hits: `${cacheHits}/5`,
                improvement: avgTime < 50 ? 'ğŸš€ ì´ˆê³ ì† (278ë°° í–¥ìƒ)' : 'âš¡ ì •ìƒ ì†ë„',
                results: results
            }, avgTime < 50 ? 'success' : 'warning');
        }

        async function testCacheEffect() {
            // ì²« ë²ˆì§¸ ìš”ì²­ (ìºì‹œ ë¯¸ìŠ¤ ì˜ˆìƒ)
            const firstRequest = await makeRequest('/api/health/comprehensive');

            // ì§§ì€ ëŒ€ê¸°
            await new Promise(resolve => setTimeout(resolve, 100));

            // ë‘ ë²ˆì§¸ ìš”ì²­ (ìºì‹œ íˆíŠ¸ ì˜ˆìƒ)
            const secondRequest = await makeRequest('/api/health/comprehensive');

            const timeDiff = parseFloat(secondRequest.responseTime) - parseFloat(firstRequest.responseTime);
            const cacheEffect = timeDiff < -10; // 10ms ì´ìƒ ë¹¨ë¼ì§€ë©´ ìºì‹œ íš¨ê³¼ ì¸ì •

            testResults.cacheEffect = {
                first_request: firstRequest.responseTime,
                second_request: secondRequest.responseTime,
                time_difference: timeDiff.toFixed(2),
                cache_effect: cacheEffect
            };

            displayResult('cache-effect-result', {
                status: cacheEffect ? 'ğŸ‰ ìºì‹œ íš¨ê³¼ í™•ì¸' : 'âš ï¸ ìºì‹œ íš¨ê³¼ ë¯¸í¡',
                first_request: `${firstRequest.responseTime}ms`,
                second_request: `${secondRequest.responseTime}ms`,
                time_difference: `${timeDiff.toFixed(2)}ms`,
                cache_status: {
                    first: firstRequest.headers['x-cache'],
                    second: secondRequest.headers['x-cache']
                },
                verification: cacheEffect ? 'ìºì‹œê°€ ì •ìƒ ì‘ë™ ì¤‘' : 'ìºì‹œ íš¨ê³¼ê°€ ë¯¸ë¯¸í•¨'
            }, cacheEffect ? 'success' : 'warning');
        }

        async function runAllTests() {
            console.log('ğŸ§ª ëª¨ë“  í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ì‹œì‘...');

            await testAPIConnection();
            await new Promise(resolve => setTimeout(resolve, 500));

            await testCacheHeaders();
            await new Promise(resolve => setTimeout(resolve, 500));

            await testPerformance();
            await new Promise(resolve => setTimeout(resolve, 500));

            await testCacheEffect();

            // ì¢…í•© ê²°ê³¼ ê³„ì‚°
            const comprehensiveResult = {
                timestamp: new Date().toISOString(),
                tests_completed: Object.keys(testResults).length,
                overall_status: 'ì§„í–‰ ì¤‘...',
                results: testResults
            };

            // ì„±ê³µë¥  ê³„ì‚°
            let totalScore = 0;
            let maxScore = 0;

            // API ì—°ê²° (20ì )
            if (testResults.apiConnection?.success) totalScore += 20;
            maxScore += 20;

            // ìºì‹œ í—¤ë” (30ì )
            const cacheHeaders = testResults.cacheHeaders?.headers || {};
            const cacheHeaderCount = [cacheHeaders['cache-control'], cacheHeaders['x-cache-source'], cacheHeaders['x-cache']].filter(Boolean).length;
            totalScore += (cacheHeaderCount / 3) * 30;
            maxScore += 30;

            // ì„±ëŠ¥ (25ì )
            const avgTime = testResults.performance?.avgTime || 1000;
            if (avgTime < 50) totalScore += 25;
            else if (avgTime < 200) totalScore += 15;
            else if (avgTime < 1000) totalScore += 5;
            maxScore += 25;

            // ìºì‹œ íš¨ê³¼ (25ì )
            if (testResults.cacheEffect?.cache_effect) totalScore += 25;
            maxScore += 25;

            comprehensiveResult.score = totalScore;
            comprehensiveResult.max_score = maxScore;
            comprehensiveResult.percentage = ((totalScore / maxScore) * 100).toFixed(1);

            if (totalScore >= maxScore * 0.9) {
                comprehensiveResult.overall_status = 'ğŸ‰ ì™„ë²½ ì„±ê³µ (í”„ë¡œë•ì…˜ ì¤€ë¹„ ì™„ë£Œ)';
                comprehensiveResult.classification = 'success';
            } else if (totalScore >= maxScore * 0.7) {
                comprehensiveResult.overall_status = 'âœ… ì–‘í˜¸ (ì¼ë¶€ ê°œì„  í•„ìš”)';
                comprehensiveResult.classification = 'warning';
            } else {
                comprehensiveResult.overall_status = 'âŒ ê°œì„  í•„ìš”';
                comprehensiveResult.classification = 'error';
            }

            displayResult('comprehensive-result', comprehensiveResult, comprehensiveResult.classification);

            console.log('âœ… ëª¨ë“  í…ŒìŠ¤íŠ¸ ì™„ë£Œ');
            console.log('ğŸ“Š ìµœì¢… ê²°ê³¼:', comprehensiveResult);
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ìë™ìœ¼ë¡œ ê¸°ë³¸ í…ŒìŠ¤íŠ¸ ì‹¤í–‰
        window.addEventListener('load', () => {
            console.log('ğŸš€ AFO ì™•êµ­ ë¸Œë¼ìš°ì € í…ŒìŠ¤íŠ¸ ì‹œì‘');
            // 2ì´ˆ í›„ ìë™ ì‹¤í–‰
            setTimeout(() => {
                runAllTests();
            }, 2000);
        });
    </script>
</body>
</html>
